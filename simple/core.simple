(define (define-macro term)
  (define params (first (rest term)))
  (define body (rest (rest term)))
  (define name (first params))
  (define args (rest params))
  (define ?helper (gensym "helper"))
  (define ?wrapper (gensym "wrapper"))
  (define ?term (gensym "term"))
  `(do 
    (define (~?helper ~@args) ~@body)
    (define (~name ~?term)
      (apply ~?helper (rest ~?term)))
    (set-macro! ~name)))

(set-macro! define-macro)

(define-macro (when test : body)
  `(if ~test (do ~@body) #nil))

(define-macro (debug _ form)
  (define ?res (gensym "res"))
  `(do
    (notify (list :debug '~form))
    (define ?res ~form)
    (prn ?res)
    ~form))

(define-macro (cond : forms)
  (define a (first forms))
  (define b (first (rest forms)))
  (define more (rest (rest forms)))
  (if (empty? forms)
    #f
    `(if ~a ~b (cond ~@more))))
 
(define-macro (or : forms)
  (define ?or (gensym "or"))
  (if (empty? forms)
    #f
    `(let (~?or ~(first forms))
      (if ~?or ~?or (or ~@(rest forms))))))

(define-macro (and : forms)
  (define ?and (gensym "and"))
  (cond 
    (empty? forms) #t
    (empty? (rest forms)) (first forms)
    :else 
    `(let (~?and ~(first forms))
      (if ~?and 
        (and ~@(rest forms)) 
        ~?and))))

(define (inc x) (+ x 1))
(define (dec x) (- x 1))
(define (identity x) x)
(define (second xs) (first (rest xs)))
(define (truthy? x) (if x #t #f))
(define (not x) (if x #f #t))
(define (not-empty? xs) (not (empty? xs)))
(define (sentinel? x) (== x :))
(define (quote? x) (and (list? x) (== 'quote (first x))))

(define (any? pred seq)
  (if (empty? seq) 
    #f 
    (or (pred (first seq)) 
        (any? pred (rest seq)))))

(define (match-pat pat in ok fail)
  (cond
    (not (symbol? in))
    (let (in* (gensym "in"))
      `(let (~in* ~in)
        ~(match-pat pat in* ok fail)))

    (quote? pat)  (match-quote pat in ok fail)
    (symbol? pat) (match-symbol pat in ok fail)
    (list? pat)   (match-list pat in ok fail)
    (array? pat)  (match-array pat in ok fail)
    :else         (match-val pat in ok fail)))

(define (match-quote pat in ok fail)
  `(if (== '~(second pat) ~in) ~ok ~fail))

(define (match-val pat in ok fail)
  (define ?val (gensym "val"))
  `(let (~?val ~pat)
    (if (== ~?val ~in)
      ~ok
      ~fail)))

(define (match-symbol pat in ok fail)
  `(let (~pat ~in) ~ok))

(define (match-list pat in ok fail)
  `(if (list? ~in)
    ~(match-list* pat in ok fail)
    ~fail))

(define (match-list* pat in ok fail)
  (cond
    (empty? pat)    
    `(if (empty? ~in) ~ok ~fail)

    (sentinel? (first pat)) 
    (match-pat (first (rest pat)) in ok fail)

    #t 
    (let* (head (first pat) 
          tail (rest pat)
          ?head (gensym "head")
          ?next (gensym "next")
          ok* `(let (~?next (rest ~in))
               ~(match-pat (rest pat) ?next ok fail)))
    `(let (~?head (first ~in))
      ~(match-pat (first pat) ?head ok* fail))))) 

(define (match-array pat in ok fail)
  `(if (and (array? ~in) (== ~(aget pat "length") (aget ~in "length")))
    ~(match-array* pat in ok fail 0)
    ~fail))

(define (match-array* pat in ok fail i)
  (if (== (aget pat "length") i) 
    ok
    (let* (x   (gensym "x")
           ok* (match-array* pat in ok fail (inc i)))
      `(let (~x (aget ~in ~i))
        ~(match-pat (aget pat i) x ok* fail)))))

(define (match-patterns clauses in)
  (define ?in (gensym "in"))
  `(let (~?in ~in)
    ~(match-patterns* clauses ?in)))

(define (match-patterns* clauses in)
  (when (not-empty? clauses)
    (define pat (first clauses))
    (define ok (second clauses))
    (define res (gensym "res"))
    (define next (match-patterns* (rest (rest clauses)) in))
    `(let (~res ~(match-pat pat in ok :match/match-failure))
      (if (== ~res :match/match-failure)
        ~next
        ~res))))

; defines a variadic function that matches on its arguments
(define-macro (define/match* name : patterns)
  (define matcher (gensym "matcher"))
  (define in (gensym "in"))
  `(do
    (define (~matcher ~in) ~(match-patterns patterns in))
    (define (~name : ~in) (~matcher ~in))))

; defines a 1-argument function that matches on its argument
(define-macro (define/match name : patterns)
  (define matcher (gensym "matcher"))
  (define in (gensym "in"))
  `(do
    (define (~matcher ~in) ~(match-patterns patterns in))
    (define (~name ~in) (~matcher ~in))))

(define-macro (match in : patterns)
  (match-patterns patterns in))

(define (atomic? x)
  (not (or (list? x) (array? x))))

(define (normalize-term m) 
  (normalize m identity))

(define (normalize-name m k)
  (normalize m (fn (n)
    (if (atomic? n)
      (k n)
      (let (t (gensym "t"))
        `(let (~t ~n) ~(k t)))))))

(define (normalize-name* m* k)
  (if (empty? m*)
    (k ())
    (normalize-name (first m*) (fn (t)
      (normalize-name* (rest m*) (fn (t*)
        (k (cons t t*))))))))

(define (normalize m k)
  (match m
    ('fn* params restparam body)
    (k `(fn* ~params ~restparam ~(normalize-term body)))
 
    (('fn* () #nil : body))
    (normalize `(do ~@body) k)

    (('fn* () restparam : body) : args)
    (normalize-name* args (fn (args*)
      `(let (~restparam (list ~@args*))
        ~(normalize `(do ~@body) k))))
    
    (('fn* (x : xs) restparam : body) arg : args)
    (normalize-name arg (fn (n)
      `(let (~x ~n)
        ~(normalize `((fn* ~xs ~restparam ~@body) ~@args) k))))

    ('if test then else)
    (normalize-name test (fn (t)
      (k `(if ~t ~(normalize-term then) ~(normalize-term else)))))

    ('do ('do : xs) : ys)
    (normalize `(do ~@xs ~@ys) k)

    ('do x)
    (k (normalize-term x))

    ('do x : xs)
    (normalize-name x (fn (_)
      (normalize `(do ~@xs) k)))

    ('quote x)
    (normalize-name x (fn (t)
      (k t)))

    ('define* name expr)
    (k `(define* ~name ~(normalize-term expr)))

    (f : xs)
    (normalize-name f (fn (f*)
      (normalize-name* xs (fn (xs*)
        (k `(~f* ~@xs*))))))

    v (k v)))

(define (directify-term term)
  (directify term '()))

(define (directify term out)
  (match term
    ('let (name expr) in)
    (cons [:set! name (first (directify-term expr))] (directify in out))
    
    ('fn* params restparam body)
    (let (ret (gensym "ret"))
      (cons 
        [:fn params restparam (directify `(let (ret ~body) ret) (list [:return 'ret]))] 
        out))

    ('define* name expr)
    (cons [:set! name expr] out)

    ('do x)
    (directify x out)

    ('do x : xs)
    (directify x (directify `(do ~@xs) out))

    (f : xs)
    (cons [:app f xs] out)

    _ out))

(define (emit term)
  (with-string-port (fn () (emit* term))))

(define/match emit*
  () #nil

  (term : terms)
  (do
    (emit* term)
    (emit* terms))

  [':fn params restparam body]
  (do
    (print "function (")
    (print (str/join "," params))
    (print ") {\n")
    (emit* body)
    (print "\n}"))

  [':set! x y]
  (do
    (emit* x)
    (print " = ")
    (emit* y)
    (print ";\n"))

  [':app f args]
  (do
    (emit* f)
    (print "(")
    (print (str/join ", " args))
    (print ")"))

  [':return x]
  (do
    (print "return ")
    (emit* x)
    (print ";"))

  any
  (print any))

(define (test form)
  @(debug)
  (define normalized (normalize-term form))
  @(debug)
  (define directified (directify-term normalized))
  @(debug)
  (define emitted (emit directified)))

(test '(f (g (if z 1 2) y)))
(test '((fn* () #nil :woot)))
(test '((fn* (x) #nil x) :woot))
(test '((fn* (x y) foo (* x y)) 1 2 3 4 5))
(test '(do (do (do (prn :woot)))))
(test '(define* x 42))
(test '(fn* (x) #nil (* x x)))

@(debug)
(prstr '(a b c))

@(debug)
(emit [:app 'f '(a b c)])